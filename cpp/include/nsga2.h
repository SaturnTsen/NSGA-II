#pragma once

#include "individual.h"
#include <cstddef>
#include <functional>

namespace nsga2 {
    /**
     * @typedef individual_t, population_t
     * @brief Alias for an individual and a population.
     */
    using individual::individual_t;
    using population_t = std::vector<individual_t>;

    /**
     * @typedef fn_t
     * @brief Alias for the objective function type.
     */
    using objective::fn_t;
} // namespace nsga2

/**
 * @namespace nsga2::end_criteria
 * @brief Namespace for NSGA-II termination end_criteria callables.
 */
namespace end_criteria {
    /**
     * @typedef criterion_t
     * @brief Alias for a callable that determines whether the algorithm should
     * terminate.
     */
    using criterion_t =
        std::function<bool(nsga2::population_t &, const size_t)>;

    /**
     * @struct max_iterations functional
     * @param max_iters Maximum number of iterations.
     */
    struct max_iterations {
        size_t max_iters;
        max_iterations(size_t max_iterations);
        bool operator()(nsga2::population_t &population,
                        const size_t iteration);
    };

    struct hit_mlotz_pareto_front {
        size_t m;
        hit_mlotz_pareto_front(size_t m);
        bool operator()(nsga2::population_t &population,
                        const size_t iteration);
    };
} // namespace end_criteria

/**
 * @namespace nsga2
 * @brief Namespace for NSGA-II (Non-dominated Sorting Genetic Algorithm II)
 * implementation.
 */
namespace nsga2 {

    class NSGA2 {
      private:
        /**
         * @brief ranks_t assigns a rank to each individual in the population.
         * @brief distances_t assigns a crowding distance to each individual in
         * a population.
         */
        using ranks_t = std::vector<std::size_t>;
        using distances_t = std::vector<double>;

      public:
        /**
         * @brief NSGA2 constructor.
         */
        NSGA2(const size_t individual_size, const size_t objective_size,
              const size_t population_size, fn_t &f,
              const double mutation_rate);

        /**
         * @brief NSGA2 constructor with mutation rate set to 1/population_size.
         */
        NSGA2(const size_t individual_size, const size_t objective_size,
              const size_t population_size, fn_t &f);

        /**
         * @brief Run the NSGA-II algorithm.
         * init_population()
         * while (termination criteria not met) {
         *   population = mutate(population)
         *   ranks = non_dominate_sort(population)
         *   select(population, ranks)
         * }
         */
        population_t run(end_criteria::criterion_t criterion);

        // To Linh Vu: In case you want to implement a deconstructor. It is not
        // necessary since all the objects are stack allocated

      private:
        /**
         * @brief f is the objective function.
         * @brief population is the current population.
         *
         */
        fn_t &f;

        // uniform random bit generator
        std::function<bool()> bit_gen;
        // Note: rand() is biased itself and should not be used in a genetic
        // algorithm

        // I don't know if adding too much comments will make the code seems to
        // be generated by a bot :D

        size_t objective_size;

        population_t population;

        const double mutation_rate;

        void init_population(size_t individual_size);

        void mutate(population_t &population);

        ranks_t non_dominate_sort(population_t &population);

        distances_t crowding_distance(population_t &population);

        void select(population_t &population, ranks_t &ranks);
    };
} // namespace nsga2